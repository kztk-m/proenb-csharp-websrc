---
title: 第6回 課題 (2025 改訂中)
---

# 基本課題

以下の要件を満たすお絵描きプログラムを作成せよ．

- 少なくとも以下のコントロールが配置されている
  - ``ColorPicker``
  - ``NumericStepper``
  - 「クリア」と書かれたボタン
  - お絵描き用のコントロール（ウィンドウの主要な面積を占める）
- マウスの主ボタン（右利き用マウスだと通常は左ボタン）を押してマウスを動かすと，線が動きに沿って描かれる．このとき，線の色は
  ``ColorPicker``で選択した色で太さが``NumericStepper``で選択した数であるとする．
  - 要はよくあるお絵描きツールの「鉛筆」ツールのような挙動をする．
- 「クリア」と書かれたボタンが押されたら，書かれた絵がクリアされる．

たとえば，以下のスクリーンショットは実装するプログラムの一例を表している．作成したアプリケーションで，この程度の絵ならばちゃんと描けるようになる（もちろんアプリケーションの挙動の意味で）ことを一つの目標にするとよい．

![作成を目指すプログラムのスクリーンショット](./images/eto/oekaki.png)

> [!TIP]
>
> お絵描き用のコントロールの``MouseMove``イベントを購読（イベントハンドラを登録）する．主ボタンが押されたまま移動されたかどうかは，以下のようにハンドラの第2引数の``Buttons``プロパティを用いて判定できる．
>
> ```cs
> // oekakiControl の MouseMove イベントを購読
> oekakiControl.MouseMove += (s, me) => {
>    if ( me.Buttons.HasFlag( MouseButtons.Primary ) ) {
>        // 主ボタンが押されたままマウスが移動したときの処理
>    }
> };
> ```

> [!TIP]
> 素朴なアイデアは``MouseMove``イベントの度に現在のマウスの位置に円を描くというものだが，それだとマウスが一度に沢山に動いたときにとぎれとぎれの「線」が描かれてしまう．それを避けるためには，以下のようにするとよいだろう．
>
> - マウスの以前の位置を覚えておく．
> - マウスの主ボタンが押されたら，その位置に円が描かれるようにし，「マウスの以前の位置」を更新する．
> - マウスの主ボタンが押されたままマウスが移動されたら，「マウスの以前の位置」と「マウスの現在の位置」の間に線分が描かれるようにする．そして，「マウスの以前の位置」を更新する．
>  
> 線分の描画には``Graphics.DrawLine(Pen, PointF, PointF)``メソッドが使用できるだろう．``Pen``の``LineCap``プロパティを``PenLineCap.Round``に設定するときれいに線が引けるかもしれない（[参考](http://pages.picoe.ca/docs/api/html/P_Eto_Drawing_Pen_LineCap.htm>)）．

> [!IMPORTANT]
> 繰り返すが，以下のコードは`Drawable`である`d`に対し，`Paint`イベントが発生したとき（≒ 描画要求があってコントロールが描画されるとき）に呼ばれる処理を追加しているのであって，*描画そのものを行っているのではない*．
>
> ```cs
> d.Paint += (s, se) => {
>     // ...
> };
> ```
>
> なので，たとえば
>
> ```cs
> oekakiControl.MouseMove += (s, me) => {
>     // ... 
>     oekakiControl.Paint += (sp, pe) => {
>         // ...
>     };
>     // ...
> };
> ```
>
> のようなコードを書くと，そもそも`oekakiControl.Paint += (sp, pe) => { ... }`の部分で描画は実行されないし，マウスを移動する度に描画要求があったときに実行する処理が増えていきだんだん描画処理が重くなっていく．
>
> 作成するお絵描き用コントロールを`oekakiControl`とすると，その`MouseMove`イベントも`Paint`イベントも購読することになるだろうが，
> 購読する部分のコードは以下のような形になるはずだ．
>
> ```cs
> oekakiControl.MouseMove += (s, me) => {
>     // ...
> };
> // ...
> oekakiControl.Paint += (s, pe) => {
>     // ....
> };
> ```
>
> なお，`oekakiControl`の（再）描画要求を投げるには`oekakiControl.Invalidate()`を呼ぶ．

# 発展課題

> [!IMPORTANT]
> 本課題を完了できたのならば本課題の解答のみを提出すればよく，基本課題の解答は提出する必要はない．

基本課題の条件を満たしている限りにおいて，お絵描きプログラムにさまざまな機能を追加せよ．追加する機能は自由に決めたのでよいが， **どのような機能を追加したかの説明およびプログラム上の工夫点はコメントとして提出プログラムに含めること．**

どういう機能を追加したらよいかまよっている人の参考までに，いくつかの機能追加の方向性を以下に示しておく．もちろん，追加する機能はこれらに限定されない．

- お絵描きした画像を保存する機能
- 「消しゴム」機能
- アンドゥ，リドゥ機能
- Shiftを押しながらクリックすると，以前に最後にマウスを離した場所との間に直線を引く
- 適当なコントロールやダイアログ等を追加し，文字列を入力できるようにする
- 「ぼかし」などのフィルタ処理
- 拡大・縮小・回転，あるいは一般の線形変換
- レイヤ機能

> [!TIP]
> 保存や読込機能の実装にはそれぞれ `OpenFileDialog` と `SaveFileDialog` を使うとよい．以下に`SaveFileDialog`の使用例を示すが，`OpenFileDialog`も同様．
>
> ```cs
> var dialog = new SaveFileDialog { Filters = {"png or jpg|png;jpg"} } ; 
> if (dialog.ShowDialog(this) == DialogResult.Ok) { // MainForm内なら．そうでなければthisの代わりに
>   var filepath = dialog.FileName; 
>   // filepath に対する処理．適切な例外処理が必要になるだろう．
> }
> ```
